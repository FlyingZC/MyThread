1.
成员变量可能会并发问题
局部变量不会


Thread类中的run()方法
private Runnable target;
//原本的run()方法啥事也没干，所以创建线程时，重写该方法
  @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
如果target不为null,则运行target对象的run()方法

private void init(){
....
  this.target = target;
  ...
	
}    

鼠标右键点方法,reference,看谁在引用该类
 public Thread(Runnable target) {
    init(null, target, "Thread-" + nextThreadNum(), 0);
}

即调用Thread(Runnable target)这个构造方法时,内部调用init()方法将target赋值给成员变量Runnable target
此时target不为null,执行run()方法时,执行target.run();


2.静态方法中不能new 内部类的对象.因为内部类的对象可以访问外部类的成员变量,但是静态方法调用时,可能外部类对象还未创建

3.wait(),notify(),zxx04 26min

4.虚拟机类Runtime类
T05ThreadLocal:一个线程内共享数据

当所有线程执行的业务代码相同,可以将代码放到runnable中,所有线程使用同一个runnable对象即可

党执行业务代码不同,可以使用多个runnable对象

***********************************
线程并发库
java.util.concurrent
一.atomic
--两个子包atomic:对数据类型的并发操作
对该数据类型的数据进行操作时,可以排斥其他线程
addAndGet(int delta)
AtomicInteger:可以用原子方式更新的 int 值
AtomicIntegerArray:可以用原子方式更新其元素的 int 数组.操作数组中的元素
AtomicIntegerFieldUpdater<T>:可以对指定类的指定 volatile int 字段进行原子更新.需要指定操作了哪个类的对象

二.线程池

--locks

Callable和Future
可以获取线程执行完的结果

Future取到的结果类型和Callable返回的结果类型必须一致.泛型实现
Callable要采用ExecutorService的submit方法提交,返回的future对象可以取消任务
CompletionService用于提交一组Callable任务,其take方法返回已完成任务的一个
Callable任务对于的Future对象
种几块麦子,哪个先成熟先收割哪个

***************
java.util.concurrent.lock
Lock
ReadWriteLock:读写锁
Condition:
Lock&Condition实现线程同步通信.比synchronized更加面向对象

hibernate中
session.load(id,User.class);
session.get(id,User.class);的区别
get()与load()
 * 执行get()方法,立即检索,会立即加载对象
 * 执行load()方法,延迟加载,若不使用该对象,则不会立即执行查询操作,而返回一个代理对象
 * 若数据表中没有对应的记录,get()返回null,load()抛出异常
 * load()方法可能会抛出LazyInitializationException.在需要初始化代理对象之前,已经关闭了session
load方法返回的是一个代理对象
User$Proxy extends User{
	private Integer id=id;
	User realUser=null;
	getName(){
		if(realUser==null){
			realUser=session.get(id);
			if(realUser==null){
				throw new Exception();
			}
		}
		return realUser.getName();
	}
}

Condition:执行条件,相当于wait和notify	通信

static 修饰的内部类





